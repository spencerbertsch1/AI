# Chickens and Foxes

Assignment 1  
CS 276, Artificial Intelligence  
Fall 2021, Dartmouth College  
Spencer Bertsch

This report contains three sections, as seen below:
* Description
* Evaluation
* Responses to Discussion Questions

# Description

The problem definition was adapted from the assignment on [gradescope.](https://www.gradescope.com/courses/297527/assignments/1483539/submissions/new)

There are three chickens and three foxes that have found themselves on one side of a river with a single boat.
Our job is to model this situation as a graph, then use uninformed search algorithms to find a solution that gets all chickens and foxes safely to the other side of the river.

Starting State:
* (3, 3, 1) - (3 chickens, 3 foxes, and 1 boat)

Constraints:
* Only two animals can fit in the boat at one time.
* In order for the boat to move from bank to bank, one animal must be in the boat to row.
* If there are ever more foxes than chickens on either bank of the river, then the chickens will get eaten.

### How do the implemented algorithms work? 

TODO 

### What design decisions were made?

TODO 

### How were the problems laid out? 

TODO 


# Evaluation

### Did the implemented algorithms work? How well did they work? 

TODO 

# Responses to Discussion Questions

### Upper Bound on States

The upper bound on the number of states, given that the starting state is (3, 3, 1) is 32 states including the start state.
The number of all possible states -- legal or illegal -- can be thought of as the combinatorial set of all integers with
maximum values of 3, 3, and 1. Ignoring the boat/not boat and simply examining the chickens and foxes, we can see that the set of available states
is: {(3,3), (3, 2), (3, 1), (3, 0), (2, 3), (2, 2), (2, 1), (2, 0), (1, 3), (1, 2), (1, 1), (1, 0), (0, 3), (0, 2), (0, 1), (0, 0)}.

From this we can conclude that adding a binary variable to the state definition (boat or not boat) would double the number of possible states.
See the below figure for a look at each of the 32 unique states.

![All vertices](https://github.com/spencerbertsch1/AI/blob/main/ChickensAndFoxes/docs/all_vertices.png?raw=true)

* **Note:** I also have PDF copies of all figures under the `docs` directory in the ChickenAndFoxes assignment. I couldn't figure out
  how to embed local PDF files into markdown docs, but if the TAs have some example code for that I will surely use that method
  in the future. For now please refer to the PNG files in the markdown and the PDF copies with the same names in the `docs` directory if more clarity is needed. 

There is a distinction between the states that are "illegal" and states that are "impossible." Illegal states can be generated by the get_successors method, 
but they are illegal because they break the chickens < foxes rule. Impossible states, on the other hand, are truly impossible to reach and the get_successors 
method will never return them. (3,3,0) is one such state; I thought this was important to note because I will be excluding the "impossible" states from my diagrams 
and I will not consider them in my code. (Because they are impossible to reach.)

![Chicken&Fox Graph](https://github.com/spencerbertsch1/AI/blob/main/ChickensAndFoxes/docs/basic_graph.png?raw=true)

Above we can see the Chicken & Fox graph up to layer 6. We can see that there exists a path from the root node to the node
(2,2,1). I assume that once we arrive at the node (2,2,1), a logical repetition can occur in the pattern of search. 

### BFS Discussion

Indeed we can see from the result of the BFS that the path found is: 

[(3, 3, 1), (2, 2, 0), (3, 2, 1), (3, 0, 0), (3, 1, 1), (1, 1, 0), (2, 2, 1), (0, 2, 0), (0, 3, 1), (0, 1, 0), (1, 1, 1), (0, 0, 0)]

Showing that the above graph representation is correct. As far as I can tell, the BFS implementation is working correctly. I implemented 
the pseudocode from the lecture slides and used a double-ended queue in python as the structure that stores the nodes in the frontier. 

We can see from running the test code in foxes.py that there is a solution for a start of (3,3,1) and (5,4,1), but not for (5,5,1). 

### DFS Discussion

* Q1: Does path-checking depth-first search save significant memory with respect to breadth-first search?

We know from the textbook and from class that in vanilla DFS saves a lot of memory over BFS, especially when b is high (b>10) or d is high (d>10). 
When either of these (or both) are the case, then DFS will use orders of magnitude less memory than BFS. 

A path-checking DFS like the one we implemented for this assignment uses path checking so we are only storing the current
path's states in the solution's path instance variable. This saves even more memory than simply keeping a set in memory and filling it 
with all the nodes that we have seen before. I'm curious if there is an expression that describes the memory saved when using 
path-checking DFS over vanilla DFS - I will check with the TAs. 



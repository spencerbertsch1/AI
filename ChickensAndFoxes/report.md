# Chickens and Foxes

Assignment 1  
CS 276, Artificial Intelligence  
Fall 2021, Dartmouth College  
Spencer Bertsch

This report contains three sections, as seen below:
* Description
* Evaluation
* Responses to Discussion Questions

# Description

The problem definition was adapted from the assignment on [gradescope.](https://www.gradescope.com/courses/297527/assignments/1483539/submissions/new)

There are three chickens and three foxes that have found themselves on one side of a river with a single boat.
Our job is to model this situation as a graph, then use uninformed search algorithms to find a solution that gets all chickens and foxes safely to the other side of the river.

Starting State:
* (3, 3, 1) - (3 chickens, 3 foxes, and 1 boat)

Constraints:
* Only two animals can fit in the boat at one time.
* In order for the boat to move from bank to bank, one animal must be in the boat to row.
* If there are ever more foxes than chickens on either bank of the river, then the chickens will get eaten.

### How do the implemented algorithms work? 

TODO 

### What design decisions were made?

TODO 

### How were the problems laid out? 

TODO 

Talk about how we laid out the code in different files. 


# Evaluation

### Did the implemented algorithms work? How well did they work? 

TODO 

# Responses to Discussion Questions

### Upper Bound on States

The upper bound on the number of states, given that the starting state is (3, 3, 1) is 32 states including the start state.
The number of all possible states -- legal or illegal -- can be thought of as the combinatorial set of all integers with
maximum values of 3, 3, and 1. Ignoring the boat/not boat and simply examining the chickens and foxes, we can see that the set of available states
is: {(3,3), (3, 2), (3, 1), (3, 0), (2, 3), (2, 2), (2, 1), (2, 0), (1, 3), (1, 2), (1, 1), (1, 0), (0, 3), (0, 2), (0, 1), (0, 0)}.

From this we can conclude that adding a binary variable to the state definition (boat or not boat) would double the number of possible states.
See the below figure for a look at each of the 32 unique states.

![All vertices](https://github.com/spencerbertsch1/AI/blob/main/ChickensAndFoxes/docs/all_vertices.png?raw=true)

* **Note:** I also have PDF copies of all figures under the `docs` directory in the ChickenAndFoxes assignment. I couldn't figure out
  how to embed local PDF files into markdown docs, but if the TAs have some example code for that I will surely use that method
  in the future. For now please refer to the PNG files in the markdown and the PDF copies with the same names in the `docs` directory if more clarity is needed. 

There is a distinction between the states that are "illegal" and states that are "impossible." Illegal states can be generated by the get_successors method, 
but they are illegal because they break the chickens < foxes rule. Impossible states, on the other hand, are truly impossible to reach and the get_successors 
method will never return them. (3,3,0) is one such state; I thought this was important to note because I will be excluding the "impossible" states from my diagrams 
and I will not consider them in my code. (Because they are impossible to reach.)

![Chicken&Fox Graph](https://github.com/spencerbertsch1/AI/blob/main/ChickensAndFoxes/docs/basic_graph.png?raw=true)

Above we can see the Chicken & Fox graph up to layer 6. We can see that there exists a path from the root node to the node
(2,2,1). I assume that once we arrive at the node (2,2,1), a logical repetition can occur in the pattern of search. 

### BFS Discussion

Indeed we can see from the result of the BFS that the path found is: 

[(3, 3, 1), (2, 2, 0), (3, 2, 1), (3, 0, 0), (3, 1, 1), (1, 1, 0), (2, 2, 1), (0, 2, 0), (0, 3, 1), (0, 1, 0), (1, 1, 1), (0, 0, 0)]

Showing that the above graph representation is correct. As far as I can tell, the BFS implementation is working correctly. I implemented 
the pseudocode from the lecture slides and used a double-ended queue in python as the structure that stores the nodes in the frontier. 

We can see from running the test code in foxes.py that there is a solution for a start of (3,3,1) and (5,4,1), but not for (5,5,1). 

### DFS Discussion

* Q1: Does path-checking depth-first search save significant memory with respect to breadth-first search?

We know from the textbook and from class that in vanilla DFS saves a lot of memory over BFS, especially when b is high (b>10) or d is high (d>10). 
When either of these (or both) are the case, then DFS will use orders of magnitude less memory than BFS. 

A path-checking DFS like the one we implemented for this assignment uses path checking so we are only storing the current
path's states in the solution's path instance variable. This saves even more memory than simply keeping a set in memory and filling it 
with all the nodes that we have seen before. I'm curious if there is an expression that describes the memory saved when using 
path-checking DFS over vanilla DFS - I will check with the TAs. 

* Q2: Draw an example of a graph where path-checking DFS takes much more run-time than breadth-first search.

This is an interesting example. The textbook describes this situation quite well; if there are multiple goals and one goal exists several layers
down starting from a left branch of the root node, then DFS will search through many nodes to find a very non-optimal solution. (See below graphic)

![Chicken&Fox Graph](https://github.com/spencerbertsch1/AI/blob/main/ChickensAndFoxes/docs/DFS_vs_BFS.png?raw=true)

This is where Iterative Deepening Depth First Search comes into action! Because vanilla DFS won't find the optimal solution and will 
often be worse than BFS in terms of time complexity, Iterative Deepening DFS was created to give us the best of both worlds. Using ID-DFS
we can begin with a Depth Limited Search with l=0 (pretty boring case), then we can move onto a Depth Limited Search where l=1, and so on. 
That way we are achieving the space complexity of DFS while also roughly achieving the completeness and optimality of BFS. 

* Q3: Does memoizing DFS save significant memory with respect to breadth-first search?  Why or why not?

Good question - as discussed above, memoizing DFS still saves memory over BFS. The space required by BFS is O(b^d) where the 
space required for DFS is O(b*m). 

### Iterative Deepening Search Discussion

Iterative deepening search was easy enough to implement, but I was initially unsure about how to break out of the loop when a solution
was found. 

* Q1: On a graph, would it make sense to use path-checking DFS, or would you prefer memoizing DFS in your iterative deepening search?  Consider both time and memory aspects.

If the solution is shallow: 
Use memoizing DFS for iteritive deepening

If the solution is deep:
Use path-checkinig DFS

### Lossy chickens and foxes

This is an interesting change to the problem definition! Intuitively I think we can arrive at the solution more quickly for solvable start states
such as (3,3,1) or (5,4,1) if E (number of dispensable chickens) was greater than 0. 

Let's look at a graph representing the first few layers of the Chicken & Fox problem in which E = 1: 

TODO 

In order to update our code to allow this, we would change the way that the state itself is represented by the tuple. Instead of a tuple of length 3, 
we can use a tuple of length 4. 

we would only need to make a change to the is_legal method of the FoxProblem class. 
The logic that is used to determine the legal nodes would change in order to take E into account so that 1, 2, 3, etc. chickens could be sacrificed. 
An upper bound on the number of states given that E = 1 would be: 

TODO 

